\chapter{Methodology}\label{chap:methodology}

This chapter presents the proposal of the pattern matching algorithm developed
during the work, as well as the  current state of its implementation.
Section~\ref{sec:parse-tress} details
the execution of a PEG for generating a parse tree and how pattern matching works.
Section~\ref{sec:implementation-details} discusses some implementation details.
Section~\ref{sec:methodology-conclusion} concludes the chapter.

\section{Parse trees}\label{sec:parse-tress}

In order to proper define pattern matching over trees, we need
to define parse trees over an arbitrary PEG. We start by defining
tree syntax and a PEG semantics which produces, as a result, such
trees. Next, we present a typing relation which assigns a parsing
expression for a given tree. Such step is necessary to formally
state the equivalence between our proposed tree-producing semantics
and PEG original semantics proposed by Ford~\cite{Ford04}.

Let \(G = (V, \Sigma, R, e_s)\) be an arbitrary PEG, the meta-variable \(a \in \Sigma\) an
arbitrary alphabet symbol, \(A \in V\) a variable and \(e\) a parsing expression.
The following context-free grammar defines the syntax of a parse tree:
\[
   \begin{array}{lcl}
      t & \to & \hat{\epsilon} \, \mid \, \hat{a} \, \mid \, A@t\,
                    \mid \, \langle t_1, t_2 \rangle\,
                    \mid \, L(e,t) \, \mid \, R(e,t) \, \mid \, [\,] \,\mid\,t:t\,
                    \mid \, \eta \\
   \end{array}
\]
Where \(\hat{\epsilon}\) represents that a parsing expression resulted in
success without consuming any symbol of its input, \(\hat{a}\) represents that
the parsing expression consumed the symbol \(a\) from the input, \(A@t\)
represents that the parsing of the rule \(A \leftarrow e \in R\) was succeesful
and $t$ is a tree for $e$. Notation
\(\langle t_1, t_2 \rangle\) represents that a sequence of parsing expressions
succeeded,
\(L \: t\) and \(R \: t\) both represent that a branch of an ordered choice succeeded,
with \(L \: t\) for the left one and \(R \: t\) for the right one,
% \(L \: t\) represents that the first expression in an ordered choice
% succeeded, \(R \: t\) represents that the second expression in an ordered choice
% succeeded,
\([]\) is an empty list of trees for $e$ and \(t_1 : t_2\) denotes a list of
trees in which $t_1$ is a tree for $e$ and $t_2$ is a tree for $e^*$. Finally,
\(\eta\) represents that a not
predicate was successful.

Executing a parsing expressions produces a parsing tree and is defined by an
inductively defined judgment that relates pairs formed by a parsing expression
and an input string to pairs formed by the generated tree and the remaining string.
Notation \((e,s_ps_r) \Downarrow_G (t,s_r)\) denote that parsing expression \(e\)
consumes the prefix \(s_p\) and generates the parse tree \(t\) from the input string
\(s_ps_r\) leaving the suffix \(s_r\). The notation \((e,s) \Downarrow_G \bot\)
denote the fact that \(s\) cannot be parsed by \(e\). We let meta-variable \(r\)
denote an arbitrary parsing result, i.e., either \(r\) is a pair \((t,s_r)\) or
\(\bot\). We say that an expression \(e\) fails if its execution over an input
produces \(\bot\); otherwise, it succeeds. Figure~\ref{fig:peg-tree-semantics}
defines the PEG semantics for tree generation.

\begin{figure}[H]
   \[
      \begin{array}{cc}
         \infer[_{\{Eps\}}]{(\epsilon,s) \Downarrow_G (\hat{\epsilon},s)}{} &
         \infer[_{\{ChrS\}}]{(a,as_r) \Downarrow_G (\hat{a},s_r)}{} \\ \\
         \infer[_{\{ChrF\}}]{(a,bs_r) \Downarrow_G \bot}{a \neq b} &
         \infer[_{\{Var\}}]{(A,s) \Downarrow_G (A@t, r)}
                        {A \leftarrow e \in R & (e,s) \Downarrow_G (t,r)} \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Cat_{S1}\}}]{(e_1\,e_2,s_{p_1}s_{p_2}s_r) \Downarrow_G (\langle t_1,t_2 \rangle, s_r)}
                                 {(e_1,s_{p_1}s_{p_2}s_r) \Downarrow_G (t_1,s_{p_2}s_r) &
                                 (e_2,s_{p_2}s_r)\Downarrow_G (t_2,s_r)}
         } \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Cat_{F2}\}}]{(e_1\,e_2,s_ps_r) \Downarrow_G \bot}
                                 { (e_1,s_ps_r) \Downarrow_G (t_1,s_r) &
                                    (e_2,s_r) \Downarrow_G \bot}} \\ \\
         \infer[_{\{Cat_{F1}\}}]{(e_1\,e_2,s)\Downarrow_G \bot}{(e_1,s) \Downarrow_G \bot} &
         \infer[_{\{Alt_{S1}\}}]{(e_1\,/\,e_2,s_p\,s_r) \Downarrow_G (L \, t,s_r)}
                                {(e_1,s_p\,s_r)\Downarrow_G (t,s_r)} \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Alt_{S2}\}}]{(e_1\,/\,e_2,s_p\,s_r) \Downarrow_G R \, t}
                                  {(e_1,s_p\,s_r)\Downarrow_G \bot &
                                   (e_2,s_p\,s_r)\Downarrow_G t}
         } \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Star_{rec}\}}]{(e^\star,s_{p_1}s_{p_2}s_r) \Downarrow_G (t_1 : t_2,s_r)}
                                 {(e,s_{p_1}s_{p_2}s_r) \Downarrow_G (t_1,s_{p_2}s_r) &
                                  (e^\star, s_{p_2}s_r) \Downarrow_G (t_2,s_r)}
         } \\ \\
         \infer[_{\{Star_{end}\}}]{(e^\star,s) \Downarrow_G ([\,],s)}
                                    {(e,s) \Downarrow_G \bot} &
         \infer[_{\{Not_F\}}]{(!\,e,s_p\,s_r) \Downarrow_G \bot}
                          {(e,s_p\,s_r) \Downarrow_G (t,s_r)}\\ \\
         \infer[_{\{Not_S\}}]{(!\,e,s) \Downarrow_G (\eta,s)}
         {(e,s) \Downarrow_G \bot}
           &
         \infer[_{\{ChrNil\}}]{(a,\epsilon) \Downarrow_G \bot}{}
      \end{array}
   \]
   \centering
   \caption{Parsing expressions operational semantics that produces a tree.}
   \label{fig:peg-tree-semantics}
\end{figure}

A parse tree is directly related to its underlying parsing expression.
We formalize this idea using a typing relation between grammars, trees and
parsing expressions. Notation $G\vdash t : e$ means that tree $t$ has
type $e$ using as assumption the variables and rules defined by grammar $G$.
Figure~\ref{fig:tree-typing} presents the rules of tree typing relation.

\begin{figure}[H]
  \[
    \begin{array}{cc}
      \infer[_{\{TEps\}}]{G \vdash \hat{\epsilon} : \epsilon}{} &
      \infer[_{\{TChr\}}]{G\vdash \hat{a} : a}{} \\ \\
      \infer[_{\{TVar\}}]{ G \vdash A@t : A}
                      {A \leftarrow e \in R(G) & G\vdash t : e} &
      \infer[_{\{TNot\}}]{G\vdash \eta : ! e}{}\\ \\
      \infer[_{\{TCat\}}]{G\vdash \langle t_1, t_2\rangle : e_1\,e_2}
                      {G\vdash  t_1 : e_1 & G\vdash t_2 : e_2} &
      \infer[_{\{TLeft\}}]{G\vdash L(e_2,t) : e_1 / e_2}
                       {G\vdash t : e_1} \\ \\
      \infer[_{\{TRight\}}]{G\vdash R(e_1,t) : e_1 / e_2}
                       {G\vdash t : e_2} &
      \infer[_{\{TNil\}}]{G \vdash [] : e^*}{}\\ \\
      \multicolumn{2}{c}{
        \infer[_{\{TCons\}}]{G \vdash t_1 : t_2 : e^*}
                         {G\vdash t_1 : e &
                          G \vdash t_2 : e^*}
      }
    \end{array}
  \]
  \centering
  \caption{Typing relation for parse trees.}
  \label{fig:tree-typing}
\end{figure}

INSERIR TEXTO EXPLICANDO CADA REGRA

Next, we need to show that our tree producing semantics is equivalent to
the original semantics for PEGs. Intuitively, our trees are a strutured
representation of the prefix parsed by a grammar. We name the textual
representation of a parse tree as its flattening which is defined
by recursion on the structure of the parse tree (Figure~\cite{fig:flattening-tree}).

\begin{figure}[H]
  \[
    \begin{array}{lcl}
      |\hat{\epsilon}| & = & \epsilon\\
      |\hat{a}| & = & a\\
      |A@t| & = & |t|\\
      |\langle t_1, t_2 \rangle| & = & |t_1|\,|t_2|\\
      |L\:t| & = & |t|\\
      |R\:t| & = & |t|\\
      |[]| & = & \epsilon \\
      |t_1 : t_2| & = & |t_1|\,|t_2|\\
    \end{array}
  \]
  \centering
  \caption{Flattening of a parse tree.}
  \label{fig:flattening-tree}
\end{figure}

EXPLICAR A FLATTENING.

The typing relation specifies what kind of parse trees are possible to be
constructed for a given parsing expression. Using the flatenning function,
we can formally describe the relation between our tree producing semantics
and PEG original semantics.
The next theorem presents this result.

\begin{theorem}[Semantics equivalence]
  Let $G$ be an arbitrary PEG. If $G \vdash t : e$ then $(e, |t|) \Downarrow_G (t, \epsilon)$ and
  $(e, |t|)\Rightarrow_G (|t|, \epsilon)$
\end{theorem}
\begin{proof}
  Induction over the derivation of $G \vdash t : e$ using the correspondent semantics rule in each case.
\end{proof}



\section{Parse tree patterns}


% Let \(G = (V, \Sigma, R, e_s)\) be an arbitrary PEG, \(\Theta\) a finite set
% of identified patterns, \(U\) a finite set of variables, the meta-variable
% \(a \in \Sigma\) an arbitrary alphabet symbol, \(A \in V\) a variable and
% \(e\) a parsing expression.

\begin{definition}[Identified pattern]
    An identified pattern is a pair \((i, p)\) where \(i\) is an identifier and
    \(p\) is a pattern.
\end{definition}

Let \(\Theta\) a finite set of identified patterns, \(U\) a finite set of
variables and \(A \in V\) a variable.
Each identified pattern \(p_i \in \Theta\) is a pair \((I, p)\), where \(I \in U\)
and \(p\) is a pattern.
The following context-free grammar defines the syntax of a pattern:
\[
    \begin{array}{lcl}
        p & \to & \epsilon \, \mid \, a \, \mid \, A\, \mid \,p_1\:p_2\,
                \mid\,p_1\,/\,p_2\, \mid \,p^\star\, \mid \,!\,p
                \mid \, M\, \mid \, I\,\\
    \end{array}
\]
Where \(\epsilon\) is a pattern that matches with the tree of empty string (\(\hat{\epsilon}\)),
\(a\) matches only with the tree of the symbol \(a\) (\(\hat{a}\)), \(A\) matches
with a subtree of type \(e\) and \((A, e) \in R\), \(p_1\:p_2\) matches if both
\(p_1\) and \(p_2\) matches sequentially. \(p_1\,/\,p_2\) matches if one of \(p_1\)
or \(p_2\) matches, \(p^\star\) will try to match \(p\) sequentially as many times
as possible, \(!p\) matches only if \(p\) does not matches. \(M\) is a meta-variable
that, given a variable \(A\), matches with any tree \(t : e\) where \((A, e) \in R\)
and \(I\) is a reference to another pattern \(p'\) where \((I, p') \in \Theta\).

Figure~\ref{fig:pattern-semantics} defines the pattern semantics.

\begin{figure*}[!ht]
    \[
        \begin{array}{ccc}
            \infer[_{\{Eps\}}]{\Theta, G \vdash \epsilon}{} &
            \infer[_{\{ChrS\}}]{\Theta, G \vdash a}{} &
            \infer[_{\{Var\}}]{\Theta, G \vdash A}{A \in V}
            \\ \\
            \infer[_{\{Sequence\}}]{\Theta, G \vdash p_1\:p_2}{\Theta, G \vdash p_1 & \Theta, G \vdash p_2} &
            \infer[_{\{Choice\}}]{\Theta, G \vdash p_1 \,/\, p_2}{\Theta, G \vdash p_1 & \Theta, G \vdash p_2} &
            \infer[_{\{Star\}}]{\Theta, G \vdash p^\star}{\Theta, G \vdash p}
            \\ \\
            \infer[_{\{Not\}}]{\Theta, G \vdash !p}{\Theta, G \vdash p} &
            \infer[_{\{MetaVar\}}]{\Theta, G \vdash M}{\exists e. M : e \land A \leftarrow e \in R} &
            \infer[_{\{Ref\}}]{\Theta, G \vdash I}{\exists e. \Theta(I) = e}
        \end{array}
    \]
    \centering
    \caption{Patterns semantics.}
    \label{fig:pattern-semantics}
\end{figure*}

\begin{definition}[Valid pattern with respect to a tree]
    We say that a pattern \(p\) is valid with respect to a tree \(t\), \(p \sim t\),
    if and only if \(\exists e . p : e \land t : e\).
\end{definition}

We also present a type coercion for parsing expressions.
\begin{figure*}[ht]
    \[
        \begin{array}{ccc}
            \infer[_{\{Reflexive\}}]{e <: e}{} &
            \multicolumn{2}{c}{
                \infer[_{\{Transitive\}}]{e_1 <: e_3}{e_1 <: e_2 & e_2 <: e_3}
            } \\ \\

            \infer[_{\{Alt_{Left}\}}]{e_1 <: e_1 / e_2}{} &
            \infer[_{\{Alt_{Right}\}}]{e_2 <: e_1 / e_2}{} &
            \infer[_{\{Star\}}]{e^n <: e^\star}{n \geq 1}
        \end{array}
    \]
    \centering
    \caption{Subtype relations for parsing expressions}
    \label{fig:subtype-relations}
\end{figure*}

We present the syntax for terms of subtyping.
\[
   \begin{array}{lcl}
      p & \to & \epsilon \, \mid \, a \, \mid \, A \,
                    \mid \,  p_1\:p_2 \, \mid \,  p_1 / p_2 \,
                    \mid \, L\:p \, \mid \, R\:p \,
                    \mid \, p^\star \, \mid \, [p] \,
                    \mid \, !\,p \, \mid \, M \\
   \end{array}
\]
Of note, are the production rules \(L\:p\), \(R\:p\) and \([p]\) which represents,
respectively, the proof that the left expression in a choice operator is a subtype
of the choice, the proof that the right expression in a choice operator is a subtype
of the choice, and the proof that a list (possibly empty) of patterns is a subtype
of the \(\star\) operator.

\begin{figure*}[ht]
    \[
        \begin{array}{ccc}
            \multicolumn{3}{c}{
                \infer[_{Pattern}]
                    {p' \sim t}
                    {p : e & e <: e' & \exists p' . p' = C(p, e <: e') & \forall t. t:e'}
            }
        \end{array}
    \]
    \centering
    \caption{Pattern coercion}
    \label{fig:pattern-coercion}
\end{figure*}
Where \(C\) is a resursively defined function that receives a pattern and a proof
that the pattern is valid and returns a corrected pattern and is defined as follows:
\[
    \begin{array}{ll}
        C(\epsilon, \epsilon)             & = \epsilon \\
        C(a, a)                           & = a \\
        C(a, a')                          & = \bot\text{, if } a \neq a' \\
        C((A\:p), (A\:p'))                & = A C(p, p') \\
        C((A\:p), (A'\:p'))               & = \bot\text{, if } A \neq A' \\
        C(M, M)                           & = M \\
        C(M, M')                          & = \bot\text{, if } M \neq M' \\
        C(p_1\:p_2, p_1'\:p_2')           & = C(p_1, p_1')\:C(p_2, p_2') \\
        C(\epsilon, xs))                  & = [] \\
        C(p, [x])                         & = [C(p, x)] \\
        C(p_1\:p_2, x:xs)                 & = C(p_1, x) \: C(p_2, xs) \\
        C(p_1 \,/\, p_2, p_1' \,/\, p_2') & = C(p_1, p_1') / C(p_2, p_2') \\
        C(p, L p')                        & = C(p, p') / !\,\epsilon \\
        C(p, R p')                        & = !\,\epsilon / C(p, p') \\
        C(p^\star, {p'}^\star)            & = (C(p, p'))^\star \\
        C(!\,p, !\,p')                    & = !\,C(p, p') \\
    \end{array}
\]


\textbf{-- Escrever regras de casamento --}
\begin{figure*}[ht]
    \[
        \begin{array}{ccc}
            % \infer[_{\{Eps\}}]{\epsilon \sim \epsilon}{} &

            % \infer[_{\{ChrS\}}]{a \sim a}{} &

            % \infer[_{\{Var\}}]{A \sim A}{} \\ \\

            % \infer[_{\{Seq\}}]
            %     {p_1\:p_2 \sim t_1\:t_2}
            %     {p_1 \sim t_1 & p_2 \sim t_2} &

            % \infer[_{\{Choice\}}]
            %     {p_1 / p_2 \sim t_1 / t_2}
            %     {p_1 \sim t_1 & p_2 \sim t_2} &

            % \infer[_{\{Star\}}]
            %     {p^\star \sim [t]}
            %     {p \sim t} \\ \\

            % \infer[_{\{Not\}}]
            %     {!\,p \sim !\,t}
            %     {p \sim t} &

            % \infer[_{\{MetaVar\}}]{M ~ t}{\exists e. M:e \land t:e} &

            % % Não tem definição de casamento pra uma referência,
            % % pq ela não existe durante o casamento
            % \\
        \end{array}
    \]
    \centering
    \caption{Matching rules}
    \label{fig:matching-rules}
\end{figure*}

\section{Implementation details}\label{sec:implementation-details}

After parsing the patterns, we replace references to other patterns with the
pattern itself. To do this, we create a dependency graph between the patterns,
topologically sort and replace the references so that no resulting pattern
contains references to other patterns and can be treated as a single pattern.

We also define two new operators for PEGs: flatten \((^\wedge e)\) and indentation
\((e_1 > e_2)\). The former flattens the parsed tree in one single node that turns
into a terminal (and can be matched as such via patterns) and the latter, for the
purpose of parsing, acts as the sequence \(e_1\:{e_2}^\star\) with the restriction
that \({e_2}^\star\) must be indented with respect to \(e_1\) and matches as if it
was a normal sequence.

\section{Conclusion}\label{sec:methodology-conclusion}

---

\cleardoublepage
